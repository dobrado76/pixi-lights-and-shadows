A Safe, Practical Implementation Plan
This is a clean, additive process that will not break your existing lighting.
Step 1: Tag Your Components in scene.json
You need to know which objects reflect and which objects are reflected.
code
JSON
// in scene.json
"scene": {
    "background2": { // This is our floor
        "image": "/textures/white-fabric-texture-background.jpg",
        "isReflectiveSurface": true, // <-- NEW PROPERTY
        "reflectionLineY": 500,     // <-- The Y-coordinate to reflect across
        //...
    },
    "ball": {
        "image": "/textures/ball.png",
        "canBeReflected": true, // <-- NEW PROPERTY
        //...
    },
    "block": {
        "image": "/textures/block.png",
        "canBeReflected": true, // <-- NEW PROPERTY
        //...
    }
}
Step 2: A New, Simple ReflectionSystem.tsx
This will be a new, self-contained component that handles the entire reflection process. It does not touch your LightingSystem or your main shaders.
src/game/core/systems/ReflectionSystem.tsx (New File)
code
Tsx
import React, { useMemo, useRef, useEffect } from 'react';
import { useApp, Container, Sprite } from '@pixi/react';
import * as PIXI from 'pixi.js';

export const ReflectionSystem = ({ sprites, reflectiveSurfaces }) => {
    const app = useApp();

    // Create a render texture to hold our reflection image
    const reflectionTexture = useMemo(() => {
        return PIXI.RenderTexture.create({
            width: app.screen.width,
            height: app.screen.height
        });
    }, [app.screen.width, app.screen.height]);

    useEffect(() => {
        const ticker = () => {
            // -- The Reflection Pass --

            // 1. Get all sprites that can be reflected
            const reflectableSprites = sprites.filter(s => s.definition.canBeReflected);
            
            // For each reflective surface (e.g., the floor)
            reflectiveSurfaces.forEach(surface => {
                const reflectionLineY = surface.definition.reflectionLineY || app.screen.height / 2;

                // 2. Temporarily transform the sprites for reflection
                reflectableSprites.forEach(sprite => {
                    if (!sprite.mesh) return;
                    // Flip the sprite's Y position across the reflection line
                    sprite.mesh.position.y = 2 * reflectionLineY - sprite.mesh.position.y;
                    // Flip the sprite's scale vertically
                    sprite.mesh.scale.y *= -1;
                });

                // 3. Render the flipped sprites to our reflection texture
                app.renderer.render(new PIXI.Container().addChild(...reflectableSprites.map(s => s.mesh)), {
                    renderTexture: reflectionTexture,
                    clear: true,
                });

                // 4. IMPORTANT: Undo the transformation immediately
                reflectableSprites.forEach(sprite => {
                    if (!sprite.mesh) return;
                    // Flip them back to their original state
                    sprite.mesh.position.y = 2 * reflectionLineY - sprite.mesh.position.y;
                    sprite.mesh.scale.y *= -1;
                });

                // 5. Apply the reflection texture to the surface's shader
                if (surface.shader) {
                    surface.shader.uniforms.uReflectionTexture = reflectionTexture;
                    surface.shader.uniforms.uReflectionEnabled = true;
                }
            });
        };

        app.ticker.add(ticker);
        return () => app.ticker.remove(ticker);

    }, [app, sprites, reflectiveSurfaces, reflectionTexture]);

    return null; // This system doesn't render anything directly to the React tree
};
Step 3: A Tiny Tweak to Your Main fragment.glsl
This is a very simple and safe addition.
src/shaders/fragment.glsl (Additions)
code
Glsl
// ... your existing varyings and uniforms ...

// --- NEW UNIFORMS FOR REFLECTION ---
uniform sampler2D uReflectionTexture;
uniform bool uReflectionEnabled;
uniform float uReflectivity; // New material property (0.0 to 1.0)

void main() {
    // ... all of your existing, working lighting, shadow, and AO code ...
    // This gives you the `finalColor`.

    vec3 finalOutput = finalColor; // Start with the lit color

    // --- NEW, ADDITIVE REFLECTION LOGIC ---
    if (uReflectionEnabled && uReflectivity > 0.0) {
        // Sample the reflection texture. We need to flip the Y-coordinate
        // because textures are often sampled from the top-left.
        vec2 reflectionUV = gl_FragCoord.xy / uCanvasSize;
        vec3 reflectionColor = texture2D(uReflectionTexture, reflectionUV).rgb;
        
        // Blend the reflection on top of the lit color based on reflectivity
        finalOutput = mix(finalOutput, reflectionColor, uReflectivity);
    }
    
    gl_FragColor = vec4(finalOutput, diffuseColor.a);
}
Step 4: Update PixiDemo.tsx
You just need to add the new ReflectionSystem and pass it the correct sprites.
code
Tsx
// in PixiDemo.tsx
import { ReflectionSystem } from './systems/ReflectionSystem';
// ...

const PixiDemo = (props) => {
    // ...
    const [sceneSprites, setSceneSprites] = useState([]);
    const [reflectiveSurfaces, setReflectiveSurfaces] = useState([]);

    useEffect(() => {
        // ... inside your setupDemo after sceneManager loads ...
        const allSprites = sceneManagerRef.current.getAllSprites();
        setSceneSprites(allSprites);
        setReflectiveSurfaces(allSprites.filter(s => s.definition.isReflectiveSurface));
    }, [/* ... */]);

    return (
        <div /* ... */>
            <Stage /* ... */>
                {/* ... your existing rendering components ... */}

                {/* Add the new, independent reflection system */}
                <ReflectionSystem
                    sprites={sceneSprites}
                    reflectiveSurfaces={reflectiveSurfaces}
                />
            </Stage>
        </div>
    );
}
Final Recommendation
Stop working on the shader-based SSR. It's a technical rabbit hole that is not necessary for the visual quality you want.
The "Inverted Render" technique is simpler, faster, more robust, and often produces visually superior results for the exact type of reflections you need. It fits your engine's architecture perfectly as an independent system and will get you to a feature-complete state in a fraction of the time. This is the right way forward.